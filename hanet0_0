import asyncio
import random
import json
import os
import sys
import urllib.request
from telethon import TelegramClient
from telethon.errors import SessionPasswordNeededError

# Текущая версия софта
CURRENT_VERSION = "1.3.0"
# Ваша ссылка на проверку версии
VERSION_URL = "https://raw.githubusercontent.com/miskabejbi-byte/soft/refs/heads/main/hanet0_0"

# Настройка для Windows (msvcrt) и Termux
try:
    import msvcrt
    WINDOWS = True
except ImportError:
    WINDOWS = False

class Colors:
    CYAN = '\033[96m'
    BLUE = '\033[94m'
    WHITE = '\033[97m'
    BOLD = '\033[1m'
    RESET = '\033[0m'

def char_gradient(text, start_count=0):
    """Окрашивает текст посимвольно: 1 голубая, 2 синяя. Работает везде (CMD/Termux)."""
    result = ""
    count = start_count
    for char in text:
        if char in [' ', '\n', '\t', '\r']:
            result += char
            continue
        color = Colors.CYAN if count % 2 == 0 else Colors.BLUE
        result += f"{color}{char}{Colors.RESET}"
        count += 1
    return result

def safe_input(prompt):
    sys.stdout.write(char_gradient(prompt))
    sys.stdout.flush()
    return input()

def gradient_input(prompt):
    """Красивый ввод. В Windows посимвольный, в Termux обычный с градиентом."""
    if not WINDOWS:
        sys.stdout.write(char_gradient(prompt))
        sys.stdout.flush()
        return input()

    sys.stdout.write(char_gradient(prompt))
    sys.stdout.flush()
    user_input = ""
    count = 0
    try:
        while True:
            if msvcrt.kbhit():
                char = msvcrt.getwch()
                if char in ('\r', '\n'):
                    sys.stdout.write('\n')
                    break
                elif char == '\b':
                    if len(user_input) > 0:
                        user_input = user_input[:-1]
                        count -= 1
                        sys.stdout.write('\b \b')
                        sys.stdout.flush()
                elif ord(char) < 32:
                    continue
                else:
                    user_input += char
                    color = Colors.CYAN if count % 2 == 0 else Colors.BLUE
                    sys.stdout.write(f"{color}{char}{Colors.RESET}")
                    sys.stdout.flush()
                    count += 1
            else:
                import time
                time.sleep(0.01)
    except:
        return input()
    return user_input

async def check_update():
    print(char_gradient("[*] Проверка версии..."))
    try:
        with urllib.request.urlopen(VERSION_URL, timeout=5) as response:
            latest_version = response.read().decode('utf-8').strip()
            if latest_version != CURRENT_VERSION:
                print(char_gradient(f"\n[!] ВНИМАНИЕ: ВЫШЛО ОБНОВЛЕНИЕ!"))
                print(char_gradient(f"[!] Ваша версия: {CURRENT_VERSION} | Новая: {latest_version}"))
                print(char_gradient(f"[!] Скачайте обновление у @miskabejbu\n"))
                await asyncio.to_thread(gradient_input, "Нажмите Enter для продолжения...")
    except:
        print(char_gradient("[!] Не удалось проверить обновления.\n"))

def resolve_id(target):
    """Обработка ID группы (например -100...) или ссылки"""
    target = str(target).strip()
    if target.startswith('-') and target[1:].isdigit():
        return int(target)
    if target.isdigit():
        return int(target)
    return target

def generate_fake_info(gender):
    countries = ["Россия", "Украина"]
    country = random.choice(countries)
    
    if country == "Россия":
        cities = ["Москва", "Санкт-Петербург", "Новосибирск", "Екатеринбург", "Казань", "Нижний Новгород", "Челябинск", "Самара", "Омск", "Ростов-на-Дону", "Уфа", "Красноярск", "Воронеж", "Пермь", "Волгоград", "Краснодар", "Саратов", "Тюмень", "Тольятти", "Ижевск", "Барнаул", "Ульяновск", "Иркутск", "Хабаровск", "Махачкала", "Владивосток"]
        phone = f"+7{random.randint(900, 999)}{random.randint(1000000, 9999999)}"
        ip = f"{random.choice([31, 46, 77, 78, 80, 81, 82, 83, 85, 87, 88, 89, 91, 92, 93, 94, 95, 109, 176, 178, 185, 188, 212, 213, 217])}.{random.randint(0, 255)}.{random.randint(0, 255)}.{random.randint(0, 255)}"
        if gender == "парень":
            names = ["Александр", "Дмитрий", "Максим", "Сергей", "Андрей", "Алексей", "Артем", "Илья", "Кирилл", "Михаил", "Никита", "Даниил", "Егор", "Павел", "Владимир", "Денис", "Роман"]
            surnames = ["Иванов", "Смирнов", "Кузнецов", "Попов", "Васильев", "Петров", "Соколов", "Михайлов", "Новиков", "Федоров", "Морозов", "Волков", "Лебедев", "Козлов", "Орлов"]
        else:
            names = ["Анастасия", "Мария", "Дарья", "Виктория", "Елизавета", "Полина", "Анна", "Ксения", "Александра", "Екатерина", "София", "Алиса", "Вероника", "Елена", "Ольга"]
            surnames = ["Иванова", "Смирнова", "Кузнецова", "Попова", "Васильева", "Петрова", "Соколова", "Михайлова", "Новикова", "Федорова", "Морозова", "Волкова", "Лебедева", "Козлова"]
    else:
        cities = ["Київ", "Харків", "Одеса", "Дніпро", "Донецьк", "Запоріжжя", "Львів", "Кривий Ріг", "Миколаїв", "Маріуполь", "Луганськ", "Вінниця", "Херсон", "Полтава", "Чернігів", "Черкаси", "Житомир", "Суми", "Рівне", "Івано-Франківськ", "Тернопіль", "Луцьк", "Ужгород"]
        phone = f"+380{random.randint(50, 99)}{random.randint(1000000, 9999999)}"
        ip = f"{random.choice([31, 37, 46, 77, 78, 80, 81, 82, 85, 88, 89, 91, 92, 93, 94, 95, 109, 159, 176, 178, 185, 188, 193, 194, 195, 212, 213, 217])}.{random.randint(0, 255)}.{random.randint(0, 255)}.{random.randint(0, 255)}"
        if gender == "парень":
            names = ["Олександр", "Дмитро", "Максим", "Сергій", "Андрій", "Олексій", "Артем", "Ілля", "Кирило", "Михайло", "Микита", "Данило", "Єгор", "Павло", "Володимир", "Богдан", "Тарас"]
            surnames = ["Шевченко", "Коваленко", "Бондаренко", "Ткаченко", "Кравченко", "Олійник", "Мельник", "Лисенко", "Зайцев", "Павленко", "Петренко", "Савченко", "Козак"]
        else:
            names = ["Анастасія", "Марія", "Дарина", "Вікторія", "Єлизавета", "Поліна", "Ганна", "Оксана", "Олександра", "Катерина", "Софія", "Аліса", "Вероніка", "Олена"]
            surnames = ["Шевченко", "Коваленко", "Бондаренко", "Ткаченко", "Кравченко", "Олійник", "Мельник", "Лисенко", "Зайцева", "Павленко", "Петренко", "Савченко", "Козак"]

    age = random.randint(11, 17)
    apt = random.randint(1, 200)
    name = random.choice(names)
    surname = random.choice(surnames)
    city = random.choice(cities)

    return (
        f"\n--- СГЕНЕРИРОВАННЫЕ ДАННЫЕ ({gender.upper()}) ---\n"
        f"ФИО: {name} {surname}\n"
        f"Возраст: {age}\n"
        f"Страна: {country}\n"
        f"Город: {city}\n"
        f"Квартира: {apt}\n"
        f"Номер: {phone}\n"
        f"IP: {ip}\n"
        f"-----------------------------"
    )

BANNER_RAW = r"""
     _               _                     _   
    | |__  _   _    | |__   __ _ _ __   ___| |_ 
    | '_ \| | | |   | '_ \ / _` | '_ \ / _ \ __|
    | |_) | |_| |   | | | | (_| | | | |  __/ |_ 
    |_.__/ \__, |   |_| |_|\__,_|_| |_|\___|\__|
           |___/                                
"""

CONFIG_FILE = 'config.json'
current_sending_task = None

def load_config():
    if os.path.exists(CONFIG_FILE):
        with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
            return json.load(f)
    return {}

def save_config(config):
    with open(CONFIG_FILE, 'w', encoding='utf-8') as f:
        json.dump(config, f, ensure_ascii=False, indent=4)

async def send_words_task(client, target_group, text):
    target_entity = resolve_id(target_group)
    words = text.split()
    for word in words:
        try:
            async with client.action(target_entity, 'typing'):
                await asyncio.sleep(len(word) * 0.02)
                await client.send_message(target_entity, word)
                await asyncio.sleep(0.1)
        except asyncio.CancelledError:
            return
        except Exception as e:
            print(f"\n{char_gradient('[!] Ошибка:')} {e}")
            break

async def main():
    global current_sending_task
    config = load_config()

    if os.name == 'nt':
        os.system('cls')
    else:
        os.system('clear')

    print(char_gradient(BANNER_RAW))
    print(char_gradient(f"юз: miskabejbu | Роль: Creator | Версия: {CURRENT_VERSION}\n"))

    await check_update()

    if 'api_id' not in config:
        config['api_id'] = int(safe_input("Введите API ID: ").strip())
        config['api_hash'] = safe_input("Введите API HASH: ").strip()
        save_config(config)

    client = TelegramClient('hanet_session', config['api_id'], config['api_hash'])
    await client.connect()

    if not await client.is_user_authorized():
        phone = safe_input("Phone: ").strip()
        await client.send_code_request(phone)
        code = safe_input("Code: ").strip()
        try:
            await client.sign_in(phone, code)
        except SessionPasswordNeededError:
            pwd = safe_input("2FA: ").strip()
            await client.sign_in(password=pwd)

    target_group = config.get('target_group', 'не указана')
    print(char_gradient(f"[*] Цель: {target_group}"))
    new_target = safe_input("[?] Новая ссылка/ID (Enter для пропуска): ").strip()
    if new_target:
        config['target_group'] = new_target
        save_config(config)
        target_group = new_target

    try:
        while True:
            print(char_gradient("\n[1] Троллинг\n[2] Создать лож инфу\n[3] Выход"))
            choice = await asyncio.to_thread(gradient_input, "Выберите действие: ")
            
            if choice == '1':
                print(char_gradient(f"\nТроллинг (Цель: {target_group}). Введите текст или 'стоп':"))
                while True:
                    text = await asyncio.to_thread(gradient_input, "Текст >> ")
                    if text.lower().strip() == 'стоп':
                        if current_sending_task: current_sending_task.cancel()
                        break
                    if text.strip():
                        if current_sending_task: current_sending_task.cancel()
                        current_sending_task = asyncio.create_task(send_words_task(client, target_group, text))

            elif choice == '2':
                print(char_gradient("\n[1] Парень | [2] Девушка | [стоп] Назад"))
                g_choice = await asyncio.to_thread(gradient_input, "Пол >> ")
                if g_choice.lower().strip() == 'стоп': continue
                gender = "девушка" if g_choice == "2" else "парень"
                print(char_gradient(generate_fake_info(gender)))
                await asyncio.to_thread(gradient_input, "\nНапишите 'стоп' или нажмите Enter для меню: ")

            elif choice == '3' or choice.lower().strip() == 'выход':
                break
    finally:
        await client.disconnect()

if __name__ == '__main__':
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print(char_gradient("\n[!] Закрыто."))
    except Exception as e:
        print(char_gradient(f"\n[КРИТИЧЕСКАЯ ОШИБКА] {e}"))
