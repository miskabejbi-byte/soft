import asyncio
import random
import json
import os
import sys
import urllib.request
from telethon import TelegramClient
from telethon.errors import SessionPasswordNeededError

# Текущая версия софта
CURRENT_VERSION = "1.2.0"
# Ссылка на файл с актуальной версией (например, на GitHub Raw)
# Замените на вашу реальную ссылку, когда зальете файл
VERSION_URL = "https://raw.githubusercontent.com/miskabejbi-byte/soft/refs/heads/main/hanet0_0"

# Пытаемся импортировать msvcrt для Windows
try:
    import msvcrt
    WINDOWS = True
except ImportError:
    WINDOWS = False

class Colors:
    CYAN = '\033[96m'
    BLUE = '\033[94m'
    WHITE = '\033[97m'
    BOLD = '\033[1m'
    RESET = '\033[0m'

def char_gradient(text, start_count=0):
    """Окрашивает текст: 1 буква голубая, 2 синяя..."""
    result = ""
    count = start_count
    for char in text:
        if char in [' ', '\n', '\t', '\r']:
            result += char
            continue
        color = Colors.CYAN if count % 2 == 0 else Colors.BLUE
        result += f"{color}{char}{Colors.RESET}"
        count += 1
    return result

def safe_input(prompt):
    """Безопасный ввод для критических данных (номер, код)."""
    sys.stdout.write(char_gradient(prompt))
    sys.stdout.flush()
    res = input()
    return res

def gradient_input(prompt):
    """Посимвольный ввод с градиентом для красоты."""
    if not WINDOWS:
        return safe_input(prompt)

    sys.stdout.write(char_gradient(prompt))
    sys.stdout.flush()
    
    user_input = ""
    count = 0
    
    try:
        while True:
            if msvcrt.kbhit():
                char = msvcrt.getwch()
                if char in ('\r', '\n'):
                    sys.stdout.write('\n')
                    break
                elif char == '\b':
                    if len(user_input) > 0:
                        user_input = user_input[:-1]
                        count -= 1
                        sys.stdout.write('\b \b')
                        sys.stdout.flush()
                elif ord(char) < 32:
                    continue
                else:
                    user_input += char
                    color = Colors.CYAN if count % 2 == 0 else Colors.BLUE
                    sys.stdout.write(f"{color}{char}{Colors.RESET}")
                    sys.stdout.flush()
                    count += 1
            else:
                import time
                time.sleep(0.01)
    except:
        return input()
            
    return user_input

async def check_update():
    """Проверка наличия обновлений"""
    print(char_gradient("[*] Проверка обновлений..."))
    try:
        # Используем стандартную библиотеку чтобы не заставлять юзеров качать requests
        with urllib.request.urlopen(VERSION_URL, timeout=5) as response:
            latest_version = response.read().decode('utf-8').strip()
            if latest_version != CURRENT_VERSION:
                print(char_gradient(f"\n[!] ДОСТУПНО ОБНОВЛЕНИЕ!"))
                print(char_gradient(f"[!] Ваша версия: {CURRENT_VERSION} | Актуальная: {latest_version}"))
                print(char_gradient(f"[!] Пожалуйста, скачайте новую версию у @miskabejbu\n"))
                await asyncio.to_thread(gradient_input, "Нажмите Enter, чтобы продолжить (или закройте софт для обновления)...")
                return False
            else:
                print(char_gradient("[+] У вас последняя версия софта.\n"))
                return True
    except Exception:
        print(char_gradient("[!] Не удалось проверить обновления (проверьте интернет).\n"))
        return True

def resolve_id(target):
    """Преобразует строку в ID (int), если это число, иначе оставляет как ссылку/юзернейм"""
    target = str(target).strip()
    if target.startswith('-'):
        if target[1:].isdigit():
            return int(target)
    elif target.isdigit():
        return int(target)
    return target

def generate_fake_info(gender):
    """Генерация ложной информации (Россия/Украина) с учетом пола"""
    countries = ["Россия", "Украина"]
    country = random.choice(countries)
    
    if country == "Россия":
        cities = ["Москва", "Санкт-Петербург", "Новосибирск", "Екатеринбург", "Казань", "Нижний Новгород", "Челябинск", "Самара", "Омск", "Ростов-на-Дону", "Уфа", "Красноярск", "Воронеж", "Пермь", "Волгоград"]
        phone = f"+7{random.randint(900, 999)}{random.randint(1000000, 9999999)}"
        ip = f"{random.choice([31, 46, 77, 78, 80, 81, 82, 83, 85, 87, 88, 89, 91, 92, 93, 94, 95, 109, 176, 178, 185, 188, 212, 213, 217])}.{random.randint(0, 255)}.{random.randint(0, 255)}.{random.randint(0, 255)}"
        
        if gender == "парень":
            names = ["Александр", "Дмитрий", "Максим", "Сергей", "Андрей", "Алексей", "Артем", "Илья", "Кирилл", "Михаил", "Никита", "Даниил", "Егор", "Павел", "Владимир"]
            surnames = ["Иванов", "Смирнов", "Кузнецов", "Попов", "Васильев", "Петров", "Соколов", "Михайлов", "Новиков", "Федоров", "Морозов", "Волков", "Лебедев", "Козлов"]
        else:
            names = ["Анастасия", "Мария", "Дарья", "Виктория", "Елизавета", "Полина", "Анна", "Ксения", "Александра", "Екатерина", "София", "Алиса", "Вероника", "Елена"]
            surnames = ["Иванова", "Смирнова", "Кузнецова", "Попова", "Васильева", "Петрова", "Соколова", "Михайлова", "Новикова", "Федорова", "Морозова", "Волкова", "Лебедева", "Козлова"]
            
    else: # Украина
        cities = ["Київ", "Харків", "Одеса", "Дніпро", "Донецьк", "Запоріжжя", "Львів", "Кривий Ріг", "Миколаїв", "Маріуполь", "Луганськ", "Вінниця", "Макіївка", "Севастополь", "Херсон"]
        phone = f"+380{random.randint(50, 99)}{random.randint(1000000, 9999999)}"
        ip = f"{random.choice([31, 37, 46, 77, 78, 80, 81, 82, 85, 88, 89, 91, 92, 93, 94, 95, 109, 159, 176, 178, 185, 188, 193, 194, 195, 212, 213, 217])}.{random.randint(0, 255)}.{random.randint(0, 255)}.{random.randint(0, 255)}"
        
        if gender == "парень":
            names = ["Олександр", "Дмитро", "Максим", "Сергій", "Андрій", "Олексій", "Артем", "Ілля", "Кирило", "Михайло", "Микита", "Данило", "Єгор", "Павло", "Володимир", "Богдан", "Тарас"]
            surnames = ["Шевченко", "Коваленко", "Бондаренко", "Ткаченко", "Кравченко", "Олійник", "Мельник", "Лисенко", "Зайцев", "Павленко", "Петренко", "Савченко", "Козак"]
        else:
            names = ["Анастасія", "Марія", "Дарина", "Вікторія", "Єлизавета", "Поліна", "Ганна", "Оксана", "Олександра", "Катерина", "Софія", "Аліса", "Вероніка", "Олена"]
            surnames = ["Шевченко", "Коваленко", "Бондаренко", "Ткаченко", "Кравченко", "Олійник", "Мельник", "Лисенко", "Зайцева", "Павленко", "Петренко", "Савченко", "Козак"]

    age = random.randint(11, 17)
    apt = random.randint(1, 200)
    name = random.choice(names)
    surname = random.choice(surnames)
    city = random.choice(cities)

    info = (
        f"\n--- СГЕНЕРИРОВАННЫЕ ДАННЫЕ ({gender.upper()}) ---\n"
        f"ФИО: {name} {surname}\n"
        f"Возраст: {age}\n"
        f"Страна: {country}\n"
        f"Город: {city}\n"
        f"Квартира: {apt}\n"
        f"Номер: {phone}\n"
        f"IP: {ip}\n"
        f"-----------------------------"
    )
    return info

BANNER_RAW = r"""
     _               _                     _   
    | |__  _   _    | |__   __ _ _ __   ___| |_ 
    | '_ \| | | |   | '_ \ / _` | '_ \ / _ \ __|
    | |_) | |_| |   | | | | (_| | | | |  __/ |_ 
    |_.__/ \__, |   |_| |_|\__,_|_| |_|\___|\__|
           |___/                                
"""

CONFIG_FILE = 'config.json'
current_sending_task = None

def load_config():
    if os.path.exists(CONFIG_FILE):
        with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
            return json.load(f)
    return {}

def save_config(config):
    with open(CONFIG_FILE, 'w', encoding='utf-8') as f:
        json.dump(config, f, ensure_ascii=False, indent=4)

async def send_words_task(client, target_group, text):
    target_entity = resolve_id(target_group)
    words = text.split()
    for word in words:
        try:
            async with client.action(target_entity, 'typing'):
                typing_delay = (len(word) * random.uniform(0.01, 0.03))
                await asyncio.sleep(typing_delay)
                await client.send_message(target_entity, word)
                await asyncio.sleep(random.uniform(0.05, 0.1))
        except asyncio.CancelledError:
            return
        except Exception as e:
            print(f"\n{char_gradient('[!] Ошибка:')} {e}")
            break
    print(f"\n{char_gradient('[+] Все слова успешно отправлены.')}")

async def main():
    global current_sending_task
    config = load_config()

    if os.name == 'nt':
        os.system('color')
        os.system('cls')
    else:
        os.system('clear')

    print(char_gradient(BANNER_RAW))
    print(char_gradient(f"юз: miskabejbu | Роль: Creator | Версия: {CURRENT_VERSION}\n"))

    # Проверка обновлений при запуске
    await check_update()

    if 'api_id' not in config or 'api_hash' not in config:
        print(char_gradient("[?] Настройка API"))
        config['api_id'] = int(safe_input("Введите API ID: ").strip())
        config['api_hash'] = safe_input("Введите API HASH: ").strip()
        save_config(config)

    api_id = config['api_id']
    api_hash = config['api_hash']

    saved_group = config.get('target_group', 'не указана')
    print(char_gradient(f"[*] Текущая цель: {saved_group}"))
    
    new_group = safe_input("[?] Введите новую ссылку или ID группы (или Enter): ").strip()

    if new_group:
        config['target_group'] = new_group
        save_config(config)
        target_group = new_group
    else:
        target_group = saved_group

    client = TelegramClient('hanet_session', api_id, api_hash)
    await client.connect()

    if not await client.is_user_authorized():
        phone = safe_input("Please enter your phone: ").strip()
        await client.send_code_request(phone)
        code = safe_input("Please enter the code: ").strip()
        try:
            user = await client.sign_in(phone, code)
        except SessionPasswordNeededError:
            password = safe_input("Please enter 2FA: ").strip()
            user = await client.sign_in(password=password)
        print(char_gradient(f"Signed in successfully!"))

    print(f"\n{char_gradient('>> СОФТ ЗАПУЩЕН <<')}\n")
    
    try:
        while True:
            print(char_gradient("\n[1] Троллинг\n[2] Создать лож инфу\n[3] Выход"))
            choice = await asyncio.to_thread(gradient_input, "Выберите действие: ")
            
            if choice == '1':
                print(char_gradient(f"\nРежим троллинга (Цель: {target_group}). Введите текст (или 'назад'):"))
                while True:
                    text = await asyncio.to_thread(gradient_input, "Текст >> ")
                    low_text = text.lower().strip()
                    
                    if low_text == 'назад':
                        await asyncio.to_thread(gradient_input, "\nНажмите Enter, чтобы вернуться в меню...")
                        break
                    if low_text == 'остановись':
                        if current_sending_task and not current_sending_task.done():
                            current_sending_task.cancel()
                            print(char_gradient("[!] Процесс остановлен."))
                        continue
                    
                    if text.strip():
                        if current_sending_task and not current_sending_task.done():
                            current_sending_task.cancel()
                        current_sending_task = asyncio.create_task(send_words_task(client, target_group, text))

            elif choice == '2':
                print(char_gradient("\n[1] Парень | [2] Девушка"))
                g_choice = await asyncio.to_thread(gradient_input, "Выберите пол: ")
                gender = "девушка" if g_choice == "2" else "парень"
                
                fake_data = generate_fake_info(gender)
                print(char_gradient(fake_data))
                
                await asyncio.to_thread(gradient_input, "\nНажмите Enter, чтобы вернуться в меню...")

            elif choice == '3':
                print(char_gradient("[!] Выход из программы..."))
                break
            else:
                print(char_gradient("[!] Неверный выбор. Попробуйте еще раз."))

    finally:
        await client.disconnect()

if __name__ == '__main__':
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print(char_gradient("\n[!] Программа закрыта."))
    except Exception as e:
        print(char_gradient(f"[КРИТИЧЕСКАЯ ОШИБКА] {e}"))
