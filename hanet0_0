import asyncio
import random
import json
import os
import sys
import urllib.request
import ssl
from telethon import TelegramClient
from telethon.errors import SessionPasswordNeededError

# Текущая версия софта
CURRENT_VERSION = "1.3.0"
# Твоя ссылка (можешь поменять окончание на .py на Гитхабе, если хочешь)
VERSION_URL = "https://raw.githubusercontent.com/miskabejbu-byte/soft/main/hanet0_0"

try:
    import msvcrt
    WINDOWS = True
except ImportError:
    WINDOWS = False

class Colors:
    CYAN = '\033[96m'
    BLUE = '\033[94m'
    WHITE = '\033[97m'
    BOLD = '\033[1m'
    RESET = '\033[0m'

def char_gradient(text, start_count=0):
    """Окрашивает текст: 1 буква голубая, 2 синяя. Работает в CMD и Termux."""
    result = ""
    count = start_count
    for char in text:
        if char in [' ', '\n', '\t', '\r']:
            result += char
            continue
        color = Colors.CYAN if count % 2 == 0 else Colors.BLUE
        result += f"{color}{char}{Colors.RESET}"
        count += 1
    return result

def safe_input(prompt):
    sys.stdout.write(char_gradient(prompt))
    sys.stdout.flush()
    return input()

def gradient_input(prompt):
    if not WINDOWS:
        sys.stdout.write(char_gradient(prompt))
        sys.stdout.flush()
        return input()
    sys.stdout.write(char_gradient(prompt))
    sys.stdout.flush()
    user_input = ""
    count = 0
    try:
        while True:
            if msvcrt.kbhit():
                char = msvcrt.getwch()
                if char in ('\r', '\n'):
                    sys.stdout.write('\n')
                    break
                elif char == '\b':
                    if len(user_input) > 0:
                        user_input = user_input[:-1]
                        count -= 1
                        sys.stdout.write('\b \b')
                        sys.stdout.flush()
                elif ord(char) < 32:
                    continue
                else:
                    user_input += char
                    color = Colors.CYAN if count % 2 == 0 else Colors.BLUE
                    sys.stdout.write(f"{color}{char}{Colors.RESET}")
                    sys.stdout.flush()
                    count += 1
            else:
                import time
                time.sleep(0.01)
    except:
        return input()
    return user_input

async def check_update():
    """Проверка версии с полным игнорированием ошибок SSL и таймаутом"""
    print(char_gradient("[*] Проверка версии..."))
    try:
        # Отключаем проверку SSL (помогает в Termux)
        ctx = ssl.create_default_context()
        ctx.check_hostname = False
        ctx.verify_mode = ssl.CERT_NONE
        
        # Притворяемся браузером
        headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)'}
        req = urllib.request.Request(VERSION_URL, headers=headers)
        
        # Ограничиваем ожидание 5 секундами, чтобы не виснуть
        with urllib.request.urlopen(req, context=ctx, timeout=5) as response:
            content = response.read().decode('utf-8').strip()
            if content and content != CURRENT_VERSION:
                print(char_gradient(f"\n[!] ВЫШЛО ОБНОВЛЕНИЕ!"))
                print(char_gradient(f"[!] Твоя версия: {CURRENT_VERSION} | Новая: {content}"))
                print(char_gradient(f"[!] Качай новую версию у @miskabejbu\n"))
                await asyncio.to_thread(gradient_input, "Нажми Enter чтобы продолжить...")
            else:
                print(char_gradient("[+] Версия актуальна.\n"))
    except:
        # Если ошибка — просто молча идем дальше
        print(char_gradient("[!] Не удалось проверить версию (скип).\n"))

def resolve_id(target):
    target = str(target).strip()
    if target.startswith('-') and target[1:].isdigit():
        return int(target)
    if target.isdigit():
        return int(target)
    return target

def generate_fake_info(gender):
    countries = ["Россия", "Украина"]
    country = random.choice(countries)
    if country == "Россия":
        cities = ["Москва", "Санкт-Петербург", "Новосибирск", "Екатеринбург", "Казань", "Нижний Новгород", "Челябинск", "Самара", "Омск", "Ростов-на-Дону"]
        phone = f"+7{random.randint(900, 999)}{random.randint(1000000, 9999999)}"
        ip = f"{random.choice([31, 46, 77, 85, 91, 178, 185])}.{random.randint(0, 255)}.{random.randint(0, 255)}.{random.randint(0, 255)}"
        if gender == "парень":
            names = ["Александр", "Дмитрий", "Максим", "Сергей", "Андрей", "Алексей"]
            surnames = ["Иванов", "Смирнов", "Кузнецов", "Попов", "Васильев", "Петров"]
        else:
            names = ["Анастасия", "Мария", "Дарья", "Виктория", "Елизавета", "Полина"]
            surnames = ["Иванова", "Смирнова", "Кузнецова", "Попова", "Васильева", "Петрова"]
    else:
        cities = ["Київ", "Харків", "Одеса", "Дніпро", "Донецьк", "Запоріжжя", "Львів", "Кривий Ріг"]
        phone = f"+380{random.randint(50, 99)}{random.randint(1000000, 9999999)}"
        ip = f"{random.choice([31, 46, 77, 91, 176, 188])}.{random.randint(0, 255)}.{random.randint(0, 255)}.{random.randint(0, 255)}"
        if gender == "парень":
            names = ["Олександр", "Дмитро", "Максим", "Сергій", "Андрій", "Олексій"]
            surnames = ["Шевченко", "Коваленко", "Бондаренко", "Ткаченко", "Кравченко"]
        else:
            names = ["Анастасія", "Марія", "Дарина", "Вікторія", "Єлизавета", "Поліна"]
            surnames = ["Шевченко", "Коваленко", "Бондаренко", "Ткаченко", "Кравченко"]

    age = random.randint(11, 17)
    apt = random.randint(1, 200)
    name = random.choice(names)
    surname = random.choice(surnames)
    city = random.choice(cities)

    return (
        f"\n--- СГЕНЕРИРОВАННЫЕ ДАННЫЕ ({gender.upper()}) ---\n"
        f"ФИО: {name} {surname}\n"
        f"Возраст: {age}\n"
        f"Страна: {country}\n"
        f"Город: {city}\n"
        f"Квартира: {apt}\n"
        f"Номер: {phone}\n"
        f"IP: {ip}\n"
        f"-----------------------------"
    )

BANNER_RAW = r"""
     _               _                     _   
    | |__  _   _    | |__   __ _ _ __   ___| |_ 
    | '_ \| | | |   | '_ \ / _` | '_ \ / _ \ __|
    | |_) | |_| |   | | | | (_| | | | |  __/ |_ 
    |_.__/ \__, |   |_| |_|\__,_|_| |_|\___|\__|
           |___/                                
"""

CONFIG_FILE = 'config.json'
current_sending_task = None

def load_config():
    if os.path.exists(CONFIG_FILE):
        with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
            return json.load(f)
    return {}

def save_config(config):
    with open(CONFIG_FILE, 'w', encoding='utf-8') as f:
        json.dump(config, f, ensure_ascii=False, indent=4)

async def send_words_task(client, target_group, text):
    target_entity = resolve_id(target_group)
    words = text.split()
    for word in words:
        try:
            async with client.action(target_entity, 'typing'):
                await asyncio.sleep(len(word) * 0.02)
                await client.send_message(target_entity, word)
                await asyncio.sleep(0.1)
        except asyncio.CancelledError:
            return
        except Exception:
            break

async def main():
    global current_sending_task
    config = load_config()

    if os.name == 'nt':
        os.system('cls')
    else:
        os.system('clear')

    print(char_gradient(BANNER_RAW))
    print(char_gradient(f"юз: miskabejbu | Роль: Creator | Версия: {CURRENT_VERSION}\n"))

    await check_update()

    if 'api_id' not in config:
        config['api_id'] = int(safe_input("Введите API ID: ").strip())
        config['api_hash'] = safe_input("Введите API HASH: ").strip()
        save_config(config)

    client = TelegramClient('hanet_session', config['api_id'], config['api_hash'])
    await client.connect()

    if not await client.is_user_authorized():
        phone = safe_input("Phone: ").strip()
        await client.send_code_request(phone)
        code = safe_input("Code: ").strip()
        try:
            await client.sign_in(phone, code)
        except SessionPasswordNeededError:
            pwd = safe_input("2FA: ").strip()
            await client.sign_in(password=pwd)

    target_group = config.get('target_group', 'не указана')
    print(char_gradient(f"[*] Цель: {target_group}"))
    new_target = safe_input("[?] Новая цель (Enter для пропуска): ").strip()
    if new_target:
        config['target_group'] = new_target
        save_config(config)
        target_group = new_target

    try:
        while True:
            print(char_gradient("\n[1] Троллинг\n[2] Создать лож инфу\n[3] Выход"))
            choice = await asyncio.to_thread(gradient_input, "Действие >> ")
            
            if choice == '1':
                print(char_gradient(f"\nТроллинг (Цель: {target_group}). Введи текст или 'стоп':"))
                while True:
                    text = await asyncio.to_thread(gradient_input, "Текст >> ")
                    if text.lower().strip() == 'стоп':
                        if current_sending_task: current_sending_task.cancel()
                        break
                    if text.strip():
                        if current_sending_task: current_sending_task.cancel()
                        current_sending_task = asyncio.create_task(send_words_task(client, target_group, text))

            elif choice == '2':
                print(char_gradient("\n[1] Парень | [2] Девушка | [стоп] Назад"))
                g_choice = await asyncio.to_thread(gradient_input, "Пол >> ")
                if g_choice.lower().strip() == 'стоп': continue
                gender = "девушка" if g_choice == "2" else "парень"
                print(char_gradient(generate_fake_info(gender)))
                await asyncio.to_thread(gradient_input, "\nНапиши 'стоп' или нажми Enter для меню: ")

            elif choice == '3' or choice.lower().strip() == 'выход':
                break
    finally:
        await client.disconnect()

if __name__ == '__main__':
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print(char_gradient("\n[!] Закрыто."))
    except Exception as e:
        print(char_gradient(f"\n[КРИТИЧЕСКАЯ ОШИБКА] {e}"))
